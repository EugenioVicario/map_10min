<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Weighted Mean Map</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <style>
        #map { height: 500px; width: 100%; margin-top: 10px; }
        #controls { padding: 10px; }
        .info.legend { 
            background: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0,0,0,0.3);
            font-size: 12px;
        }
        .info.legend i {
            width: 20px;
            height: 20px;
            display: inline-block;
            margin-right: 5px;
        }
    </style>
</head>
<body>
    <h2>Weighted Mean Map</h2>
    <div id="controls">
        <label>Weight for Education: <input type="number" id="weightEdu" value="0.5" min="0" max="1" step="0.01"></label>
        <label>Weight for Health: <input type="number" id="weightHealth" value="0.5" min="0" max="1" step="0.01"></label>
        <label>Weight for Leisure: <input type="number" id="weightLeisure" value="0.5" min="0" max="1" step="0.01"></label>
        <label>Weight for Food Retail: <input type="number" id="weightFoodRetail" value="0.5" min="0" max="1" step="0.01"></label>
        <label>Weight for Primary School: <input type="number" id="weightPrimarySe" value="0.5" min="0" max="1" step="0.01"></label>
        <label>Weight for Parks: <input type="number" id="weightParks" value="0.5" min="0" max="1" step="0.01"></label>
        <button onclick="updateMap()">Apply Weights</button>
    </div>
    <div id="map"></div>

    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script>
        var map = L.map('map').setView([0, 0], 2);  // Default centered on (0,0) to start

        var geojsonData; // This will store the GeoJSON data
        var geojsonLayer;

        // Function to generate color based on the weighted mean value
        function getColor(value, min, max) {
            let normalized = (value - min) / (max - min); // Normalize to range [0,1]
            return normalized > 0.8 ? '#800026' :
                   normalized > 0.6 ? '#BD0026' :
                   normalized > 0.4 ? '#E31A1C' :
                   normalized > 0.2 ? '#FC4E2A' : '#FFEDA0';
        }

        // Function to update the map with new weights
        function updateMap() {
            let weightEdu = parseFloat(document.getElementById('weightEdu').value);
            let weightHealth = parseFloat(document.getElementById('weightHealth').value);
            let weightLeisure = parseFloat(document.getElementById('weightLeisure').value);
            let weightFoodRetail = parseFloat(document.getElementById('weightFoodRetail').value);
            let weightPrimarySe = parseFloat(document.getElementById('weightPrimarySe').value);
            let weightParks = parseFloat(document.getElementById('weightParks').value);

            let weightSum = weightEdu + weightHealth + weightLeisure + weightFoodRetail + weightPrimarySe + weightParks;

            if (geojsonLayer) map.removeLayer(geojsonLayer);

            // Compute min/max based on the new weight range
            let minWeightedMean = 0;  // Minimum value is always 0
            let maxWeightedMean = weightSum; // Maximum is always the sum of all weights

            geojsonLayer = L.geoJSON(geojsonData, {
                style: function(feature) {
                    // Calculate the weighted mean using all fields
                    let weightedMean = (
                        feature.properties.Education * weightEdu +
                        feature.properties.Health * weightHealth +
                        feature.properties.Leisure * weightLeisure +
                        feature.properties.Food_Retai * weightFoodRetail +
                        feature.properties.Primary_Se * weightPrimarySe +
                        feature.properties.Parks * weightParks
                    ) / weightSum;

                    return { 
                        fillColor: getColor(weightedMean, minWeightedMean, maxWeightedMean),
                        fillOpacity: 0.7, 
                        color: "transparent", // Border color is transparent
                        weight: 0 
                    };
                },
                onEachFeature: function(feature, layer) {
                    // Calculate weighted mean for popup
                    let weightedMean = (
                        feature.properties.Education * weightEdu +
                        feature.properties.Health * weightHealth +
                        feature.properties.Leisure * weightLeisure +
                        feature.properties.Food_Retai * weightFoodRetail +
                        feature.properties.Primary_Se * weightPrimarySe +
                        feature.properties.Parks * weightParks
                    ) / weightSum;

                    layer.bindPopup(` 
                        <b>Region:</b> ${feature.properties.name}<br>
                        <b>Education:</b> ${feature.properties.Education}<br>
                        <b>Health:</b> ${feature.properties.Health}<br>
                        <b>Leisure:</b> ${feature.properties.Leisure}<br>
                        <b>Food Retail:</b> ${feature.properties.Food_Retai}<br>
                        <b>Primary School:</b> ${feature.properties.Primary_Se}<br>
                        <b>Parks:</b> ${feature.properties.Parks}<br>
                        <b>Weighted Mean:</b> ${weightedMean.toFixed(2)}
                    `);
                }
            }).addTo(map);

            // Center the map on the centroid of the dataset
            var bounds = geojsonLayer.getBounds();
            map.fitBounds(bounds);  // Fit map bounds to the GeoJSON data

            // Update the legend with the new weighted mean range
            updateLegend(minWeightedMean, maxWeightedMean);
        }

        // Function to update the legend
        function updateLegend(minWeightedMean, maxWeightedMean) {
            // Remove the previous legend before adding a new one
            if (map._controlCorners["topright"].firstChild) {
                map.removeControl(map._controlCorners["topright"].firstChild);
            }

            var legend = L.control({ position: 'topright' });

            legend.onAdd = function () {
                var div = L.DomUtil.create('div', 'info legend');
                var grades = [
                    minWeightedMean,
                    minWeightedMean + (maxWeightedMean - minWeightedMean) * 0.2,
                    minWeightedMean + (maxWeightedMean - minWeightedMean) * 0.4,
                    minWeightedMean + (maxWeightedMean - minWeightedMean) * 0.6,
                    minWeightedMean + (maxWeightedMean - minWeightedMean) * 0.8,
                    maxWeightedMean
                ];
                var colors = ['#FFEDA0', '#FC4E2A', '#E31A1C', '#BD0026', '#800026'];
                var labels = [];

                // Generate the legend color boxes with values based on weighted sum
                for (var i = 0; i < grades.length - 1; i++) {
                    labels.push(
                        '<i style="background:' + colors[i] + '"></i> ' +
                        grades[i].toFixed(2) + '&ndash;' + grades[i + 1].toFixed(2)
                    );
                }

                div.innerHTML = labels.join('<br>');
                return div;
            };

            legend.addTo(map);
        }

        // Load the GeoJSON data
        fetch('indicatore_02.geojson')  // Ensure the correct path to your GeoJSON file
            .then(response => response.json())
            .then(data => {
                geojsonData = data;
                updateMap(); // Initial rendering
            });
    </script>
</body>
</html>


